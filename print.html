<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ISCP Documentation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/01.html"><strong aria-hidden="true">2.1.</strong> The Solo package</a></li><li class="chapter-item expanded "><a href="tutorial/02.html"><strong aria-hidden="true">2.2.</strong> Tokens and the Value Tangle</a></li><li class="chapter-item expanded "><a href="tutorial/03.html"><strong aria-hidden="true">2.3.</strong> Creating a chain. Core contacts</a></li><li class="chapter-item expanded "><a href="tutorial/04.html"><strong aria-hidden="true">2.4.</strong> Deploying and running Rust smart contract</a></li><li class="chapter-item expanded "><a href="tutorial/05.html"><strong aria-hidden="true">2.5.</strong> Structure of the smart contract</a></li><li class="chapter-item expanded "><a href="tutorial/06.html"><strong aria-hidden="true">2.6.</strong> Invoking smart contract. Sending a request</a></li><li class="chapter-item expanded "><a href="tutorial/07.html"><strong aria-hidden="true">2.7.</strong> Calling a view from the Solo environment</a></li><li class="chapter-item expanded "><a href="tutorial/08.html"><strong aria-hidden="true">2.8.</strong> Sending and receiving tokens with the address</a></li><li class="chapter-item expanded "><a href="tutorial/09.html"><strong aria-hidden="true">2.9.</strong> Sending tokens to the smart contract</a></li><li class="chapter-item expanded "><a href="tutorial/10.html"><strong aria-hidden="true">2.10.</strong> Return of tokens in case of failure</a></li><li class="chapter-item expanded "><a href="tutorial/11.html"><strong aria-hidden="true">2.11.</strong> Sending iotas from smart contract to address</a></li></ol></li><li class="chapter-item expanded "><a href="setup_wasp.html"><strong aria-hidden="true">3.</strong> Setup a private ISCP Cluster</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">ISCP Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-the-iscp-documentation"><a class="header" href="#welcome-to-the-iscp-documentation">Welcome to the ISCP Documentation</a></h1>
<p>{{ #include ../README.md:4: }}</p>
<h1 id="exploring-iota-smart-contracts"><a class="header" href="#exploring-iota-smart-contracts">Exploring IOTA Smart Contracts</a></h1>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The document is an introductory tutorial of the IOTA Smart Contract 
platform (ISCP) for developers. </p>
<p>The level of the document is technical. The target audience is software engineers who want 
to understand ISCP and the direction it is taking, in order to develop their own dApps 
and/or contribute to the development of the ISCP and the Wasp node. </p>
<p>The approach in this tutorial is to introduce to main concepts through writing
unit tests of example smart contracts. 
We use Go testing package codenamed <a href="tutorial/../../packages/solo/readme.html"><em>Solo</em></a> in all examples of the tutorial.</p>
<p>The knowledge of Go programming and basics of Rust programming is a prerequisite. </p>
<h2 id="chapters"><a class="header" href="#chapters">Chapters</a></h2>
<ul>
<li><a href="tutorial/01.html">The <em>Solo</em> package</a></li>
<li><a href="tutorial/01.html#first-example">First example</a></li>
<li><a href="tutorial/02.html#tokens-and-the-value-tangle">Tokens and the Value Tangle</a></li>
<li><a href="tutorial/03.html#creating-a-chain-core-contracts">Creating a chain. Core contracts</a></li>
<li><a href="tutorial/03.html#writing-and-compiling-first-rust-smart-contract">Writing and compiling first Rust smart contract</a></li>
<li><a href="tutorial/04.html#deploying-and-running-rust-smart-contract">Deploying and running Rust smart contract</a></li>
<li><a href="tutorial/05.html#structure-of-the-smart-contract">Structure of the smart contract</a>
<ul>
<li><a href="tutorial/05.html#state">State</a></li>
<li><a href="tutorial/05.html#entry-points">Entry points</a></li>
</ul>
</li>
<li><a href="tutorial/05.html#panic-exception-handling">Panic. Exception handling</a></li>
<li><a href="tutorial/06.html">Invoking a smart contract</a>
<ul>
<li><a href="tutorial/06.html">Sending a request</a></li>
<li><a href="tutorial/07.html">Calling a view</a></li>
</ul>
</li>
<li><a href="tutorial/08.html">Sending and receiving funds by example</a>
<ul>
<li><a href="tutorial/08.html#sending-and-receiving-tokens-with-the-address">Sending and receiving tokens with the address</a></li>
<li><a href="tutorial/09.html#sending-tokens-to-the-smart-contract">Sending tokens to the smart contract</a></li>
<li><a href="tutorial/10.html#return-of-tokens-in-case-of-failure">Return of tokens in case of failure</a></li>
<li><a href="tutorial/11.html">Sending iotas from smart contract to address</a> </li>
</ul>
</li>
<li><a href="tutorial/iscp_accounts.html">ISCP on-chain accounts. Controlling token balances</a></li>
</ul>
<h2 id="annexes"><a class="header" href="#annexes">Annexes</a></h2>
<ul>
<li><a href="tutorial/root.html"><code>root</code> contract</a></li>
<li><a href="tutorial/accounts.html"><code>accounts</code> contract</a></li>
<li><a href="tutorial/blob.html"><code>blob</code> contract</a></li>
<li><a href="tutorial/eventlog.html"><code>eventlog</code> contract</a></li>
</ul>
<h1 id="exploring-iota-smart-contracts-1"><a class="header" href="#exploring-iota-smart-contracts-1">Exploring IOTA Smart Contracts</a></h1>
<h2 id="the-solo-package"><a class="header" href="#the-solo-package">The <em>Solo</em> package</a></h2>
<p>Solo is a Go package to write tests for IOTA smart contracts. 
It allows the deployment of ISCP chains and smart contracts. It also provides a toolkit for interaction 
with smart contracts, for manipulation of tokens and ledger accounts in an environment that is almost 
identical to the distributed multi-chain environment of the ISCP. </p>
<p>The <code>Solo</code> package and its <code>GoDoc</code> link <a href="tutorial/../../packages/solo/readme.html">can be found here</a>. 
The GoDocs provides a reference to all Solo calls which can be used in tests (not necessarily covered in this tutorial). </p>
<p>Smart contracts are notoriously isolated from the outside world. 
The effect of the user interaction with a smart contract is normally only observed in its state change. 
The approach in this tutorial is to explain all main concepts of ISCP development through 
loading smart contracts into the <em>Solo</em> tests, invoking its functions and examining state changes.</p>
<p>ISCP is currently in active development, so things change and are less than perfect. 
In the current stage the ISCP software is experimental. 
We expect feedback from the community about hands-on experience. 
We also expect contribution to the development of ISCP itself, including Rust/Wasm development environment 
or, possibly, alternative VM implementations. </p>
<p><em>Solo</em> is not a toy environment. It allows developers to develop and test real smart contracts and 
entire inter-chain protocols before deploying them on the distributed network.</p>
<p>Please follow <a href="tutorial/install.html">the link</a> for installation instructions.</p>
<h2 id="first-example"><a class="header" href="#first-example">First example</a></h2>
<p>The following is an example of a <em>Solo</em> test. 
It deploys a new chain and invokes a function in the <code>root</code> contract. </p>
<p>The <code>root</code> contract always exists on any chain. 
So for this example there is no need to deploy any new contract.
The test log to the testing output the main parameters of the chain, lists names and IDs of all four core contracts.</p>
<pre><code class="language-go">func TestTutorial1(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex1&quot;)

	chainInfo, coreContracts := chain.GetInfo()   // calls view root::GetInfo
	require.EqualValues(t, 4, len(coreContracts)) // 4 core contracts deployed by default

	t.Logf(&quot;chainID: %s&quot;, chainInfo.ChainID)
	t.Logf(&quot;chain owner ID: %s&quot;, chainInfo.ChainOwnerID)
	for hname, rec := range coreContracts {
		t.Logf(&quot;    Core contract '%s': %s&quot;, rec.Name, coretypes.NewContractID(chain.ChainID, hname))
	}
}
</code></pre>
<p>The output of the test will be something like this:</p>
<pre><code>=== RUN   TestTutorial1
18:47.411	INFO	TestTutorial1	solo/solo.go:160	deploying new chain 'ex1'
18:47.415	INFO	TestTutorial1.ex1	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CziZYb8ZkqwgftQ9Am8sz2GTM3EEevWHGSVfuzx74Wan: Ok'
18:47.416	INFO	TestTutorial1.ex1	solo/run.go:82	state transition #0 --&gt; #1. Requests in the block: 1. Posted: 0
18:47.416	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
18:47.416	INFO	TestTutorial1.ex1	solo/solo.go:240	chain 'ex1' deployed. Chain ID: Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf
18:47.416	INFO	TestTutorial1.ex1	solo/req.go:172	callView: root::getChainInfo
    tutorial_test.go:21: chainID: Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf
    tutorial_test.go:22: chain owner ID: A/MRVBJxYjreRDiEaAYNKaoHMS8y4DPZKHHJNxf2fP7zxb
    tutorial_test.go:24:     Core contract 'eventlog': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::661aa7d8
    tutorial_test.go:24:     Core contract 'blob': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::fd91bc63
    tutorial_test.go:24:     Core contract 'root': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::cebf5908
    tutorial_test.go:24:     Core contract 'accounts': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::3c4b5e02
--- PASS: TestTutorial1 (0.01s)
</code></pre>
<p>The 4 core contracts listed in the log (<code>root</code>, <code>accounts</code>, <code>blob</code>, <code>eventlog</code>) 
are automatically deployed on each new chain. You can see them listed in the test log together with their <em>contract IDs</em>.</p>
<p>The output fragment in the log <code>state transition #0 --&gt; #1</code> means the state of the chain has changed from block 
index 0 (the origin index of the empty state) to block index 1. 
The state #0 is the empty origin state, the #1 always contains all core smart contracts deployed on the chain as well as other 
variables of chain, such as <em>chainID</em> and <em>chain owner ID</em>.</p>
<p>The <em>chainID</em> and <em>chain owner ID</em> are respectively ID of the deployed 
chain <code>Ygtcnzs4zHF3Ao9i5FytNT5oYykUvYtuJSSANuxohcoo</code> and the address (in the form of <em>agent ID</em>) 
from which the chain was deployed: <code>A/RxRUJAcHajNX1A3bFBdECxQVkNwELTnPfU7aNboEz9hN</code>
(the prefix <code>A/</code> indicates that the chain owner is an address, not a smart contract).</p>
<p>Next: <a href="tutorial/02.html">Tokens and the Value Tangle</a></p>
<h1 id="exploring-iota-smart-contracts-2"><a class="header" href="#exploring-iota-smart-contracts-2">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/01.html">Exploring IOTA Smart Contracts</a></p>
<h2 id="tokens-and-the-value-tangle"><a class="header" href="#tokens-and-the-value-tangle">Tokens and the Value Tangle</a></h2>
<p>The Pollen release of the Goshimmer node implements the <em>Value Tangle</em>, 
a distributed ledger of tokens. We won't go into the detail of the Value Tangle. The introduction 
of it can be found <a href="tutorial/../intro/utxo.html">here</a>. We only have to know that Value Tangle contains
balances of colored tokens locked in addresses, like this: </p>
<pre><code>Address: Yk85765qdrwheQ4udj6RihxtPxudTSWF9qYe4NsAfp6K
   IOTA: 1000
   Red: 15
   Green: 200
</code></pre>
<p>where <code>IOTA</code> is the color code of IOTA tokens and <code>Red</code> and <code>Green</code> are other color codes 
(<a href="https://github.com/iotaledger/goshimmer/blob/87d0cbb172c1b3432b1dddcbabacd76cad66f1f3/dapps/valuetransfers/packages/balance/color.go#L10">color codes are 32-byte hashes, as defined by Goshimmer</a>). 
Tokens can only be moved on the <em>Value Tangle</em> by the private key of the corresponding address. </p>
<p>(In this tutorial we will use <code>private key</code>, <code>signature scheme</code> and <code>wallet</code> as synonyms).</p>
<p>The <code>Solo</code> environment implements in-memory Value Tangle ledger to the finest details. 
For example, you can only move tokens in the <em>Solo</em> environment by creating and submitting valid and signed transaction. 
You can also create new wallets on the Value Tangle and request iotas from the faucet to your wallet.</p>
<p>The following code shows how to do it:</p>
<pre><code class="language-go">func TestTutorial2(t *testing.T) {
	env := solo.New(t, false, false)
	userWallet := env.NewSignatureSchemeWithFunds() // create new wallet with 1337 iotas
	userAddress := userWallet.Address()
	t.Logf(&quot;Address of the userWallet is: %s&quot;, userAddress)
	numIotas := env.GetAddressBalance(userAddress, balance.ColorIOTA) // how many iotas contains the address
	t.Logf(&quot;balance of the userWallet is: %d iota&quot;, numIotas)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337) // assert the address has 1337 iotas
}
</code></pre>
<p>The output of the test:</p>
<pre><code>=== RUN   TestTutorial2
    tutorial_test.go:32: Address of the userWallet is: RPfqfAKuBFc5dLMqDtshTbRXPJcuyBYLo9WnqMkf6PaU
    tutorial_test.go:34: balance of the userWallet is: 1337 iota
--- PASS: TestTutorial2 (0.00s)
</code></pre>
<p>The token ledger of the Value Tangle in <em>Solo</em> &quot;lives&quot; in the global environment <code>env</code>
of the test. It is shared among all chains, deployed on that environment. 
It serves as a medium for transactions between smart contracts on different chains. 
The way <em>Solo</em> makes it possible to test transacting between chains.</p>
<p>Note that in the test above we didn’t deploy any chains: the Value Tangle exists 
outside of any chains.</p>
<p>Next: <a href="tutorial/03.html">Creating a chain. Core contracts</a></p>
<h1 id="exploring-iota-smart-contracts-3"><a class="header" href="#exploring-iota-smart-contracts-3">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/02.html">Tokens and the Value Tangle</a></p>
<h2 id="creating-a-chain-core-contracts"><a class="header" href="#creating-a-chain-core-contracts">Creating a chain. Core contracts</a></h2>
<p>In a test we can deploy one or several chains, deploy smart contracts in it and invoke them. </p>
<p>In the above example <code>TestTutorial1</code>, the statement <code>chain := env.NewChain(nil, &quot;ex1&quot;)</code> 
creates and deploys a new chain <code>ex1</code> in the environment of the test. 
Several chain may be deployed on the test.</p>
<p>Deploying a chain automatically means deployment of all 4 core smart contracts on it.
The core contracts are responsible for the vital functions of the chain and provide infrastructure 
for all other smart contracts:</p>
<ul>
<li>
<p><code>root</code> <a href="tutorial/root.html">contract</a>. 
Responsible for the initialization of the chain, maintains the global parameters 
and the registry of deployed contracts.
It also handles fees and performs other functions. </p>
</li>
<li>
<p><code>accounts</code> <a href="tutorial/accounts.html">contract</a>. 
Responsible for the on-chain ledger of accounts. 
The on-chain accounts contain colored tokens, which are controlled by smart 
contracts and addresses on the Value Tangle. </p>
</li>
<li>
<p><code>blob</code> <a href="tutorial/blob.html">contract</a>. 
Responsible for the immutable registry of binary objects of arbitrary size. 
One blob is a collection of named binary chunks of data. 
For example, a blob can be used to store a collections of <em>wasm</em> binaries, needed to deploy <em>WebAssembly</em> smart contracts. 
Each blob in the registry is referenced by its hash which is deterministically calculated from data. </p>
</li>
<li>
<p><code>eventlog</code> <a href="tutorial/eventlog.html">contract</a>. 
Keeps an immutable log of events in the chain. Each event is a message, a string, 
emitted by smart contracts with the <code>Event()</code> sandbox call. 
The events are published over the Wasp node publisher for consumption of outside subscribers. 
Each events is also immutably stored in the <code>eventlog</code> on the chain with the timestamp and id 
of the smart contract which emitted the event. 
Important events such as the deployment of a new smart contract or processing 
of a request are emitted as events by the chain's core. </p>
</li>
</ul>
<h2 id="writing-and-compiling-first-rust-smart-contract"><a class="header" href="#writing-and-compiling-first-rust-smart-contract">Writing and compiling first Rust smart contract</a></h2>
<p>In this section we will create a new smart contract. 
We will write its code in Rust then will use the <code>wasplib</code> <a href="tutorial/../../contracts/rust/wasmlib">library</a> and <code>wasm-pack</code> 
to compile it into WebAssembly (<em>wasm</em>) binary. </p>
<p>Note that this tutorial is not a tutorial of the ISCP smart contract development environment: 
for that we will provide other tutorials. 
The only goal of these examples is an introduction to fundamental principles of ISCP smart contracts.</p>
<p>We assume you already have Rust and <code>wasm-pack</code> <a href="https://rustwasm.github.io/wasm-pack/installer/">installed</a>. </p>
<p>We will be using the examples located in the <code>wasp repository</code> at 
<a href="tutorial/example-tutorial">articles/tutorial/example-tutorial</a> directory. </p>
<p>The <code>example-tutorial</code> smart contract is a simple smart contract which stores a string in its state upon request and allows to 
retrieve the stored string by calling a view. The smart contract also implements an entry point which allows the creator
of the smart contract instance to withdraw all iotas contained in the smart contract's account on the chain.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmlib::*;

const PARAM_STRING: &amp;str = &quot;paramString&quot;;
const VAR_STRING: &amp;str = &quot;storedString&quot;;

#[no_mangle]
fn on_load() {
    // declare entry points of the smart contract
    let exports = ScExports::new();
    exports.add_call(&quot;storeString&quot;, store_string);
    exports.add_view(&quot;getString&quot;, get_string);
    exports.add_call(&quot;withdrawIota&quot;, withdraw_iota);
}

// storeString entry point stores a string provided as parameters
// in the state as a value of the key 'storedString'
// panics if parameter is not provided
fn store_string(ctx: &amp;ScFuncContext) {
    // take parameter paramString
    let par = ctx.params().get_string(PARAM_STRING);
    // require parameter exists
    ctx.require(par.exists(), &quot;string parameter not found&quot;);

    // store the string in &quot;storedString&quot; variable
    ctx.state().get_string(VAR_STRING).set_value(&amp;par.value());
    // log the text
    let msg = &quot;Message stored: &quot;.to_string() + &amp;par.value();
    ctx.log(&amp;msg);
}

// getString view returns the string value of the key 'storedString'
// The call return result as a key/value dictionary.
// the returned value in the result is under key 'paramString'
fn get_string(ctx: &amp;ScViewContext) {
    // take the stored string
    let s = ctx.state().get_string(VAR_STRING).value();
    // return the string value in the result dictionary
    ctx.results().get_string(PARAM_STRING).set_value(&amp;s);
}

// withdraw_iota sends all iotas contained in the contract's account
// to the caller's L1 address.
// Panics of the caller is not an address
// Panics if the address is not the creator of the contract is the caller
// The caller will be address only if request is sent from the wallet on the L1, not a smart contract
fn withdraw_iota(ctx: &amp;ScFuncContext) {
    let creator = ctx.contract_creator();
    let caller = ctx.caller();

    ctx.require(creator.equals(&amp;caller), &quot;not authorised&quot;);
    ctx.require(caller.is_address(), &quot;caller must be an address&quot;);

    let bal = ctx.balances().balance(&amp;ScColor::IOTA);
    if bal &gt; 0 {
        ctx.transfer_to_address(&amp;caller.address(), &amp;ScTransfers::new(&amp;ScColor::IOTA, bal))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running the <code>wasm-pack build</code> command will produce something like this:</p>
<pre><code>[INFO]: Checking for the Wasm target...
[INFO]: Compiling to Wasm...
    Finished release [optimized] target(s) in 0.07s
[INFO]: License key is set in Cargo.toml but no LICENSE file(s) were found; Please add the LICENSE file(s) to your project directory
[INFO]: Installing wasm-bindgen...
[INFO]: Optimizing wasm binaries with `wasm-opt`...
[INFO]: :-) Done in 1.75s
[INFO]: :-) Your wasm pkg is ready to publish at [...]]\github.com\iotaledger\wasplib\rust\contracts\examples\example1\pkg.
</code></pre>
<p>The 30KB file <code>example_tutorial_bg.wasm</code> is the binary of the smart contract. We will be using it in further examples. 
The file contains everything needed to deploy the smart contract on a chain run by the Wasp network.</p>
<p>Next: <a href="tutorial/04.html">Deploying and running Rust smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-4"><a class="header" href="#exploring-iota-smart-contracts-4">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/03.html"> Creating a chain. Core contracts. Writing and compiling first Rust smart contract</a></p>
<h2 id="deploying-and-running-rust-smart-contract"><a class="header" href="#deploying-and-running-rust-smart-contract">Deploying and running Rust smart contract</a></h2>
<p>The following <em>Solo</em> test deploys <em>wasm</em> contract on the chain.
Then it invokes it: first it posts a request <code>storeString</code> to set the string value,
then it calls the view 'getString' to retrieve the value and checks it.</p>
<pre><code class="language-go">func TestTutorial3(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex3&quot;)
	// deploy the contract on chain
	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// call contract to store string
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;)
	_, err = chain.PostRequest(req, nil)
	require.NoError(t, err)

	// call the contract to extract value of the 'paramString' and check
	res, err := chain.CallView(&quot;example1&quot;, &quot;getString&quot;)
	require.NoError(t, err)
	returnedString, exists, err := codec.DecodeString(res.MustGet(&quot;paramString&quot;))
	require.NoError(t, err)
	require.True(t, exists)
	require.EqualValues(t, &quot;Hello, world!&quot;, returnedString)
}
</code></pre>
<p>Running the test will produce the following output:</p>
<pre><code>=== RUN   TestTutorial3
30:13.101	INFO	TestTutorial1	solo/solo.go:160	deploying new chain 'ex3'
30:13.108	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]9fx8mFGHNpXToAdR9QyA3vf56Z4kVV7EuvnfPXSJHYAK: Ok'
30:13.109	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #0 --&gt; #1. Requests in the block: 1. Posted: 0
30:13.109	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.109	INFO	TestTutorial1.ex3	solo/solo.go:240	chain 'ex3' deployed. Chain ID: SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT
30:13.113	INFO	TestTutorial1.ex3	solo/req.go:172	callView: blob::getBlobInfo
30:13.114	INFO	TestTutorial1.registry.registry	registry/blobcache.go:43	data blob has been stored. size: 30293 bytes, hash: EUZHCU4fEXT7obcMVj5EjMsrCyyRC4ZaWK6LkyFNL1UN
30:13.114	INFO	TestTutorial1	solo/solo.go:382	Solo::PutBlobDataIntoRegistry: len = 30293, hash = EUZHCU4fEXT7obcMVj5EjMsrCyyRC4ZaWK6LkyFNL1UN
30:13.114	INFO	TestTutorial1.ex3	solo/req.go:172	callView: root::getFeeInfo
30:13.114	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: blob::storeBlob -- [0]Gq8zyjz3rj9keZf3LvNjkWscGRVBhV1U1enJwYv7Jsig
30:13.115	INFO	TestTutorial1.ex3	vmcontext/log.go:4	eventlog::fd91bc63 -&gt; '[blob] hash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, field sizes: [30293 10]'
30:13.115	INFO	TestTutorial1.ex3	vm/event.go:24	SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT::fd91bc63/event [blob] hash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, field sizes: [30293 10]
30:13.115	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]Gq8zyjz3rj9keZf3LvNjkWscGRVBhV1U1enJwYv7Jsig: Ok'
30:13.118	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #1 --&gt; #2. Requests in the block: 1. Posted: 0
30:13.118	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.119	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: root::deployContract -- [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S
30:13.219	INFO	TestTutorial1.ex3	vmcontext/log.go:4	eventlog::cebf5908 -&gt; '[deploy] name: example1 hname: ffb07aeb, progHash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, dscr: 'N/A''
30:13.219	INFO	TestTutorial1.ex3	vm/event.go:24	SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT::cebf5908/event [deploy] name: example1 hname: ffb07aeb, progHash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, dscr: 'N/A'
30:13.219	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S: Ok'
30:13.221	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #2 --&gt; #3. Requests in the block: 1. Posted: 0
30:13.222	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.223	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: example1::storeString -- [0]DAE2wTgPP36jeQk6EWCqpHhenZzEbjiZRgkSXcEVK5ak
30:13.227	INFO	TestTutorial1.ex3	vmcontext/log.go:4	Message stored: Hello, world!
30:13.228	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]DAE2wTgPP36jeQk6EWCqpHhenZzEbjiZRgkSXcEVK5ak: Ok'
30:13.229	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
30:13.229	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.229	INFO	TestTutorial1.ex3	solo/req.go:172	callView: example1::getString
--- PASS: TestTutorial3 (0.13s)
</code></pre>
<p>The final state of the chain is <code>#4</code>. The chain changes its state in response to the requests.</p>
<p><code>state transition #0 --&gt; #1</code> settles initial state of the chain (see <a href="tutorial/01.html">First example</a>).</p>
<p>The <code>state transition #1 --&gt; #2</code> and <code>state transition #2 --&gt; #3</code> are result of the <code>Solo</code> 
call <code>err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)</code>:</p>
<ul>
<li>First state transition corresponds to the storing the <em>wasm</em> binary file as a binary object into the chain.</li>
<li>Second is the deployment of the smart contract based on this binary object (which is already on the chain).</li>
</ul>
<p>The <code>state transition #3 --&gt; #4</code> corresponds to sending the string <code>Hello, world!</code> by posting a <code>storeString</code> request to 
the newly deployed smart contract.</p>
<p>The test then calls the view <code>getString</code> of the smart contract and asserts the returned string is <code>Hello, world!</code>.
Note that calling the view state transition doesn't occur.</p>
<p>Next: <a href="tutorial/05.html">Structure of the smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-5"><a class="header" href="#exploring-iota-smart-contracts-5">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/04.html">Deploying and running Rust smart contract</a></p>
<h2 id="structure-of-the-smart-contract"><a class="header" href="#structure-of-the-smart-contract">Structure of the smart contract</a></h2>
<p>Smart contracts are programs immutably stored in the chain. 
In the example above the binary file with the code of the smart contract with binary <em>example_tutorial_bg.wasm</em> will 
be immutably stored in the chain state.</p>
<p>The logical structure of an ISCP smart contract is independent of the VM type we use, 
be it a <em>Wasm</em> smart contract or any other. </p>
<p><img src="tutorial/SC-structure.png" alt="" /></p>
<p>Each smart contract on the chain is identified by its name hashed into 4 bytes and interpreted as <code>uint32</code> value: 
the so called <code>hname</code>. For example, the <code>hname</code> of the root contract is <em>0xcebf5908</em>, the 
unique identifier of the <code>root</code> contract in every chain.</p>
<p>Each smart contract instance has a program with a collection of entry points and a state. 
An entry point is a function of the program through which the program can be invoked. 
The <code>example1</code> contract above has three entry points: <code>storeString</code>, <code>getString</code> and <code>withdrawIota</code>.</p>
<p>There are several ways to invoke an entry point: a request, a call and a view call, 
depending on the type of the entry point.</p>
<p>The smart contract program can access its state and account through an interface layer called the <em>Sandbox</em>. </p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>The smart contract state is its data, with each update stored on the chain. 
The state can only be modified by the smart contract program itself. There are two parts of the state:</p>
<ul>
<li>A collection of key/value pairs called the <code>data state</code>. 
Each key and value are byte arrays of arbitrary size (there are practical limits set by the database, of course). 
The value of the key/value pair is always retrieved by its key.</li>
<li>A collection of <code>color: balance</code> pairs called the <code>account</code>. The account represents the balances of tokens 
of specific colors controlled by the smart contract. 
Receiving and spending tokens into/from the account means changing the account's balances.</li>
</ul>
<p>Only the smart contract program can change its data state and spend from its account. 
Tokens can be sent to the smart contract account by any other agent on the ledger, 
be it a wallet with an address or another smart contract. </p>
<p>See <a href="tutorial/accounts.html">Accounts</a> for more info on sending and receiving tokens.</p>
<h3 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h3>
<p>There are two types of entry points:</p>
<ul>
<li><em>Full entry points</em> or just <em>entry points</em>. These functions can modify (mutate) the state of the smart contract.</li>
<li><em>View entry points</em> or <em>views</em>. These are read-only functions. 
They are used only to retrieve the information from the smart contract state. 
They can’t modify the state, i.e. are read-only calls.</li>
</ul>
<p>The <code>example1</code> program has three entry points: </p>
<ul>
<li>
<p><code>storeString</code> a full entry point. 
It first checks if parameter called <code>paramString</code> exist. 
If so, it stores the string value of the parameter into the state variable <code>storedString</code>.
If parameter <code>paramString</code> is missing, the program panics. </p>
</li>
<li>
<p><code>getCounter</code> is a view entry point that returns the value of the variable <code>storedString</code>.</p>
</li>
<li>
<p><code>withdrawIota</code> full entry point checks if the caller is and address and if the caller is equal to 
the creator of smart contract. If not, it panics. If it passes the validation, the program sends all of iotas
contained in the account to the caller.</p>
</li>
</ul>
<p>Note that in <code>example1</code> the Rust function associated with the full entry point takes parameters of type <code>ScFuncContext</code>.
It gives full (read-write) access to the state. 
In contrast, <code>getCounter</code> is a view entry point and its associated function has type <code>ScViewContext</code>. 
The view is not allowed to mutate the state.</p>
<h2 id="panic-exception-handling"><a class="header" href="#panic-exception-handling">Panic. Exception handling</a></h2>
<p>The following test posts a request to <code>example1</code> smart contract without expected parameter <code>paramString</code>.
The statement <code>ctx.require(par.exists(), &quot;string parameter not found&quot;);</code> makes 
smart contract panic if the condition is not satisfied.</p>
<pre><code class="language-go">func TestTutorial4(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex4&quot;)
	// deploy the contract on chain
	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// call contract incorrectly
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;)
	_, err = chain.PostRequest(req, nil)
	require.Error(t, err)
}
</code></pre>
<p>The fragment in the output of the test:</p>
<pre><code>30:13.315	PANIC	TestTutorial1.ex4	vmcontext/log.go:12	string parameter not found
30:13.319	ERROR	TestTutorial1.ex4	vmcontext/runreq.go:172	recovered from panic in VM: string parameter not found
30:13.319	INFO	TestTutorial1.ex4	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]4ert8Wkqf8vVY8Px9QEXABFewh2zgi2ksFeiL4X8xCWm: recovered from panic in VM: string parameter not found'
30:13.322	INFO	TestTutorial1.ex4	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
</code></pre>
<p>It shows the panic occured indeed. The test passes because error was expected.</p>
<p>Note that this test ends with the state <code>#4</code>, despite the fact that last request to the smart contract failed.
This is important: <strong>whatever happens during the run of the smart contract's entry point, 
processing of each request always results in the state transition</strong>. </p>
<p>The VM context catches exceptions (panics) in the program. 
Consequences of it are recorded in the state of the chain during the fallback processing, no matter if the panics
was called by the logic of the smart contract or another runtime error occured. </p>
<p>In the case of <code>example1</code> the error event was recorded in the immutable event log of the chain, 
but the data state of the smart contract wasn't modified.<br />
In other cases the fallback actions may be more complex.</p>
<p>Next: <a href="tutorial/06.html">Invoking smart contract. Sending a request</a></p>
<h1 id="exploring-iota-smart-contracts-6"><a class="header" href="#exploring-iota-smart-contracts-6">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/05.html#panic-exception-handling">Deploying and running Rust smart contract</a></p>
<p>(see also <a href="tutorial/invoking.html">General scheme of invoking the entry point</a>)</p>
<h2 id="invoking-smart-contract-sending-a-request"><a class="header" href="#invoking-smart-contract-sending-a-request">Invoking smart contract. Sending a request</a></h2>
<p>The statements</p>
<pre><code>	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;)
	_, err = chain.PostRequest(req, nil)
</code></pre>
<p>In the above example <code>TestTutorial3</code> invokes the <code>storeString</code> entry point of the <code>example1</code> smart contract 
by posting a request to it. It passes the parameter named <code>paramString</code> with the string value &quot;Hello, world!&quot;.
The <em>Solo</em> test itself is outside of the chain where smart contract is invoked, not &quot;on-chain&quot;.</p>
<p><code>NewCallParams</code> creates a call object <code>req</code> which wraps all call parameters into a single object. This is syntactic sugar 
just for convenience. In this case the call object only wraps target smart contract name, target entry point's name 
together with one named parameter <code>paramString</code>. In other cases it could contain many parameters and transferred tokens. </p>
<p><code>PostRequest</code> sends the request to the chain. Let’s describe in detail what is going on here.</p>
<p><img src="tutorial/send_request.png" alt="" /></p>
<p>The diagram above depicts the generic process of posting a request to the smart contract. 
The same picture is valid for the <em>Solo</em> environment and for any other requester which sends a request to 
the smart contract, for example ISCP wallet or another chain.</p>
<p>Posting the request always consists of steps below. 
Note that in Solo all 7 steps are carried out by the single call to <code>PostRequest</code>.</p>
<ol>
<li>Creating the smart contract transaction which wraps the request with 
metadata and moves tokens. Each request transaction is a value transaction, it always moves at least one token. 
Therefore, each request transaction must be signed by the private key of the owner of the tokens: 
the requester. It makes each requester securely identified in ISCP. 
In Solo the transaction is signed by the private key provided in the second parameter of the 
<code>PostRequest</code> call (see below);</li>
<li>Posting the request transaction to the Tangle and confirming it. 
In <em>Solo</em> it is just adding the transaction to the <code>UTXODB ledger</code>, the emulated Value Tangle, 
so it is confirmed immediately and synchronously. 
The confirmed transaction on the ledger becomes part of the backlog of requests to the chain. 
In the real Value Tangle the sender would have to wait until the ledger confirms the transaction;</li>
<li>The chain picks the request from the backlog and runs the request on the VM;</li>
<li>The VM calls the target entry point of the smart contract program. The program updates the state;</li>
<li>The VM produces a state update transaction (anchor); </li>
<li>Chain signs the transaction with the private key. In the <em>Solo</em> environment it is <code>ChainSigScheme</code> property of the chain.<br />
In the real Wasp environment it is the threshold signature of the committee;</li>
<li>The chain posts the resulting transaction to the Tangle and confirms it. 
In the <em>Solo</em> environment it adds it to the UTXODB ledger. </li>
</ol>
<p>The following lines in the log corresponds to the step 7:</p>
<pre><code>30:13.219	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S: Ok'
30:13.221	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #2 --&gt; #3. Requests in the block: 1. Posted: 0
</code></pre>
<p>the chain adds record about successfully processed request <code>[0]3U4weXHjSRzAi57hXCDp2X3ej7t8ZRtkVAWkAn2XTZLe</code> 
to the immutable on-chain log.</p>
<p>The statement <code>_, err = chain.PostRequest(req, nil)</code> 
in the Solo test uses <code>nil</code> for the default signature scheme of the requester. 
The <code>OriginatorSigScheme</code>, the one which deployed the chain, is used as the default requester. 
In the <em>Solo</em> environment you can create other identities of requesters (“wallets”) with <code>NewSignatureSchemeWithFunds</code>.</p>
<p>Next: <a href="tutorial/07.html">Invoking smart contract. Calling a view</a></p>
<h1 id="exploring-iota-smart-contracts-7"><a class="header" href="#exploring-iota-smart-contracts-7">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/06.html">Invoking smart contract. Sending a request</a></p>
<h2 id="calling-a-view-from-the-solo-environment"><a class="header" href="#calling-a-view-from-the-solo-environment">Calling a view from the Solo environment</a></h2>
<p>The statement in the above example calls a view entry point <code>getString</code> of the smart contract <code>example1</code> without parameters:</p>
<pre><code>res, err := chain.CallView(&quot;example1&quot;, &quot;getString&quot;)
</code></pre>
<p>The call returns a result res, a collection of key/value pairs and error (if not <code>nil</code>).</p>
<p><img src="tutorial/call_view.png" alt="" /></p>
<p>The basic principle of calling a view is similar to the sending a request to the smart contract. 
The essential difference is that calling a view is not a transaction but just a synchronous call 
to the view entry point function, exposed by the smart contract.</p>
<p>Naturally, calling a view doesn't involve any token transfer. 
Sending a request (a transaction) to a view entry point will result in an exception. It will return 
all attached tokens back to the sender (minus fees, if any).</p>
<p>Views are used to retrieve information about the state of the smart contract, 
for example to display it on a website. Certain <em>Solo</em> methods such as <code>chain.GetInfo</code>, 
<code>chain.GetFeeInfo</code> and <code>chain.GetTotalAssets</code> call views of the core smart contracts behind scenes 
to retrieve the information about the chain or a specific smart contract.</p>
<h3 id="decoding-results-returned-by-postrequest-and-callview"><a class="header" href="#decoding-results-returned-by-postrequest-and-callview">Decoding results returned by <em>PostRequest</em> and <em>CallView</em></a></h3>
<p>The following is the technicality of the Go environment of <em>Solo</em>.</p>
<p>The result returned by the call to the entry point from the <em>Solo</em> environment is in the form of key/value pairs, 
the <code>dict.Dict</code> type. 
It is an extended interface and alias of the <code>map[string][]byte</code>. 
The <a href="https://github.com/iotaledger/wasp/blob/master/packages/kv/dict/dict.go">dict.Dict</a> package implements 
<code>kv.KVStore</code> interface and provides a lot of useful functions to handle this form of key/value storage.</p>
<p>In normal operation of smart contracts one can only retrieve results returned by view calls, 
since view calls are synchronous. 
On the other hand, sending a request to a smart contract is an asynchronous operation, and 
the caller cannot retrieve the result. 
However, in the <em>Solo</em> environment, the call to <code>PostRequest</code> is synchronous, and the caller can inspect 
the result: this is a convenient difference between the mocked <em>Solo</em> environment and a 
distributed Value Tangle ledger used by Wasp nodes. 
It can be used to make assertions on the result of the call in the test.</p>
<p>The example <code>res</code> is a dictionary where keys and values are binary slices. The statement</p>
<pre><code>counter, exists, err := codec.DecodeInt64(res.MustGet(&quot;counter&quot;)) 
</code></pre>
<p>takes the value of the key <code>counter</code> from the key value store and attempts to decode it as <code>int64</code>.
The decoding returns a possible error value, existence flag and the value itself.</p>
<p>Next: <a href="tutorial/08.html">Sending and receiving tokens with the address</a> </p>
<h1 id="exploring-iota-smart-contracts-8"><a class="header" href="#exploring-iota-smart-contracts-8">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/07.html">Calling a view from the Solo environment</a></p>
<p>For general description of ISCP account system see <a href="tutorial/iscp_accounts.html">ISCP accounts. Controlling token balances</a>.</p>
<h2 id="sending-and-receiving-tokens-with-the-address"><a class="header" href="#sending-and-receiving-tokens-with-the-address">Sending and receiving tokens with the address</a></h2>
<p>Multiple chains in ISCP adds another dimension to the ledger: smart contract can exchange assets between themselves
on different chains as well as with addresses on the Value Tangle, the <code>L1</code>. 
We will skip explaining the whole picture for time being and will concentrate on one specific use case.</p>
<p>Let's say we are a wallet, we have private key (the address) and some tokens on it. 
The use case is about sending tokens to and receiving from a smart contract on a chain.</p>
<p>Here we explore the concept of <code>on-chain account</code> or just <code>account</code>. 
On the Value Tangle ledger the private key is represented by the address (the hash of the public key). 
That address holds balances of colored tokens. Those tokens are &quot;controlled&quot; by the private key.</p>
<p>In ISCP we extend the concept of <em>address</em> with the concept of <code>account</code>. <code>account</code> contains colored tokens just like 
and <code>address</code>.
The <code>account</code> is located on some chain and it is controlled by the same private key (an address). 
So, address can control token on the Value Tangle (<code>L1</code>) and on each of chains (<code>L2</code>).</p>
<p>The chain essentially is a custodian of the tokens deposited on it's <code>accounts</code>.</p>
<p>The following test demonstrates how a wallet can deposit tokens on chain account and then withdraw it back.</p>
<pre><code class="language-go">func TestTutorial5(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex5&quot;)

	// create wallet with 1337 iotas.
	// wallet has address and it is globally identified through
	// universal identifier: the agent ID
	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userAddress)

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337) // 1337 on address
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)  // empty on-chain

	t.Logf(&quot;Address of the userWallet is: %s&quot;, userAddress)
	numIotas := env.GetAddressBalance(userAddress, balance.ColorIOTA)
	t.Logf(&quot;balance of the userWallet is: %d iota&quot;, numIotas)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)

	// send 42 iotas from wallet to own account on-chain, controlled by the same wallet
	req := solo.NewCallParams(accounts.Name, accounts.FuncDeposit).
		WithTransfer(balance.ColorIOTA, 42)
	_, err := chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	// check address balance: must be 43 (!) iotas less
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-43)
	// check the on-chain account. Must contain 43 (!) iotas
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 43)

	// withdraw back all iotas
	req = solo.NewCallParams(accounts.Name, accounts.FuncWithdrawToAddress)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	// we are back to initial situation: IOTA is fee-less!
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0) // empty
}
</code></pre>
<p>The example above creates a chain, then creates a wallet with 1337 iotas and sends (deposits) 42 iotas
to the corresponding on-chain account by posting a <code>deposit</code> request to the <code>accounts</code> core contract on that chain. 
That account will contain 43 iotas (1 iota more for technical reasons which 
we skip here). The address on the Value Tangle will contain 43 iotas less, of course.</p>
<p>In the next step the same wallet (<code>userWallet</code>) will withdraw all 43 iotas back to the address by sending <code>withdraw</code>
request to the <code>accounts</code> contract on the same chain. </p>
<p>If the same request would be posted from another user wallet (another private key), the <code>withdraw</code> request would fail.
Try it! Only owner of the address can move those funds from the on-chain account.</p>
<p>Next: <a href="tutorial/09.html">Sending tokens to the smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-9"><a class="header" href="#exploring-iota-smart-contracts-9">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/08.html">Sending and receiving tokens with address</a></p>
<h2 id="sending-tokens-to-the-smart-contract"><a class="header" href="#sending-tokens-to-the-smart-contract">Sending tokens to the smart contract</a></h2>
<p>Let's send some tokens to the smart contract. The following example deploys familiar <code>example1</code> 
Rust/Wasm smart contract on the chain and sends 42 iota to it.</p>
<pre><code class="language-go">func TestTutorial6(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex6&quot;)

	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)     // empty on-chain

	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 42)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-43)
}
</code></pre>
<p>The statement</p>
<pre><code>	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).WithTransfer(balance.ColorIOTA, 42)
</code></pre>
<p>attaches 42 iotas to the usual call to <code>storeString</code> entry point. 
<code>PostRequest</code> sends a request with all iotas to the smart contract. 
The 42 iotas appear in the account controlled by the smart contract on its chain.
<code>userAgent</code> has 1 iota controlled by it on the chain (for a reason we skip here). </p>
<p>So, what <code>example1</code> smart contract does with these 42 iotas? Nothing! However, the creator (and nobody else) 
of the smart contract may withdraw those iotas to it's own address by sending a request <code>withdrawIotas</code>.</p>
<p>What if we send some other colored tokens, not iotas to the <code>example1</code> smart contract? 
They will be effectively lost, because programmer of the <code>example1</code> smart contract didn't implement methods 
to deal with colored tokens. </p>
<p>Next: <a href="tutorial/10.html">Return of tokens in case of failure</a></p>
<h1 id="exploring-iota-smart-contracts-10"><a class="header" href="#exploring-iota-smart-contracts-10">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/09.html">Sending atokens to the smart contract</a></p>
<h2 id="return-of-tokens-in-case-of-failure"><a class="header" href="#return-of-tokens-in-case-of-failure">Return of tokens in case of failure</a></h2>
<p>Natural question: what if I attach tokens to the request, send it to the smart contract and smart contract fails (panics)?
The panics may occur for whatever reason: it may be due to wrong parameters or it may be a runtime error, a bug. 
What will happen with my tokens?</p>
<p>The following test demonstrates the situation when the request results in the panic in the smart contract.</p>
<pre><code class="language-go">func TestTutorial7(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex7&quot;)

	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)     // empty on-chain

	// missing parameter, will panic
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.Error(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-1)
}
</code></pre>
<p>The programmer forgets the parameter <code>paramString</code> and the program panics:</p>
<pre><code>30:13.501	PANIC	TestTutorial1.ex7	vmcontext/log.go:12	string parameter not found
30:13.501	ERROR	TestTutorial1.ex7	vmcontext/runreq.go:172	recovered from panic in VM: string parameter not found
30:13.501	INFO	TestTutorial1.ex7	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]Ge4WLPVN7dGfW7uViwDLYQh8FVpvWsZG2GkYKYdtezA8: recovered from panic in VM: string parameter not found'
30:13.508	INFO	TestTutorial1.ex7	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
</code></pre>
<p>We can see that all sent 42 tokens are returned to the sender's address. The 1 iota token is accrued 
to the sender (<code>userWallet</code>) on the chain. </p>
<p>In case of panic for whatever reason, the fallback logic of the VM context of ISCP returns all 
tokens (less fees) to the sender's location (to the sender's address the example above). </p>
<p>Next: <a href="tutorial/11.html">Sending iotas from smart contract to address</a> </p>
<h1 id="exploring-iota-smart-contracts-11"><a class="header" href="#exploring-iota-smart-contracts-11">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="tutorial/10.html">Return of tokens in case of failure</a> </p>
<h2 id="sending-iotas-from-smart-contract-to-address"><a class="header" href="#sending-iotas-from-smart-contract-to-address">Sending iotas from smart contract to address</a></h2>
<p>The programmer of the <code>example</code> smart contract implemented entry point <code>withdrawIota</code>. What it is for?
If not this method, any tokens sent to the smart contract will be essentially lost: there's no other 
way to withdraw tokens back to address. </p>
<p>The entry point require from the caller to be an address and to be equal to <code>creator</code> of the instance of the 
contract. The <code>creator</code> (its <code>agentID</code>) is always contained in the registry of contracts. If conditions
are not satisfied, the call panics.</p>
<p>If condition satisfied, the contract calls the <code>transfer_to_address</code> sandbox function to send all iotas, owned by the
contract to the caller, the address.</p>
<p>What if we send some other colored tokens, not ordinary iotas, to the smart contract? Those will stay there 
forever, because in this contract we can only withdraw iotas.</p>
<p>The following <em>Solo</em> test demonstrates how it works:</p>
<pre><code class="language-go">func TestTutorial8(t *testing.T) {
	// create solo environment
	env := solo.New(t, false, false)
	// deploy new chain
	chain := env.NewChain(nil, &quot;ex8&quot;)

	// create a user's wallet (private key) and request 1337 iotas from the faucet.
	// It corresponds to L1 address
	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())
	t.Logf(&quot;userAgentID: %s&quot;, userAgentID)

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0) // empty on-chain

	// the chain owner (default) send a request to the root contract to grant right to deploy
	// contract on the chain to the use
	req := solo.NewCallParams(root.Interface.Name, root.FuncGrantDeploy, root.ParamDeployer, userAgentID)
	_, err := chain.PostRequest(req, nil)
	require.NoError(t, err)

	// user deploys wasm smart contract on the chain under the name &quot;example1&quot;
	// the wasm binary is in the file
	err = chain.DeployWasmContract(userWallet, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	// the deployment of the smart contract required 1 requests to the root contract:
	// - to submit binary to the on-chain &quot;blob&quot; registry
	// - to deploy contract from the blob
	// Two tokens were taken from the user account to form requests and then were
	// deposited to the user's account on the chain
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-2)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 2)

	// user send a &quot;storeString&quot; request to the smart contract. It attaches 42 iotas to the request
	// It also takes 1 iota for the request token
	// Result is 42 iotas moved to the smart contract's account
	req = solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 42)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 3)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-45)

	// user withdraws all iotas from the smart contract back
	// Out of 42 iotas 41 iota is coming back to the user's address, 1 iotas
	// is accrued to the user on chain
	req = solo.NewCallParams(&quot;example1&quot;, &quot;withdrawIota&quot;)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 3+1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-45+41)
}
</code></pre>
<p>Next: <a href="tutorial/iscp_accounts.html">ISCP accounts. Controlling token balances</a> </p>
<h1 id="setup-a-private-iscp-cluster"><a class="header" href="#setup-a-private-iscp-cluster">Setup a private ISCP Cluster</a></h1>
<h1 id="wasp-cluster"><a class="header" href="#wasp-cluster">wasp-cluster</a></h1>
<p><code>wasp-cluster</code> is a tool that allows to easily run a cluster of Wasp nodes
along with a Goshimmer node (needed for Wasp), all in a single host, to
experiment with smart contracts in a controlled environment.</p>
<p>Note: <code>wasp-cluster</code> is intended for testing purposes, and is <em>not</em> the
recommended way to run a cluster in a production environment.</p>
<h2 id="before"><a class="header" href="#before">Before</a></h2>
<p>Make sure you have all needed binaries compiled and installed in the system path:</p>
<ul>
<li><code>goshimmer</code> (Goshimmer server with the <code>waspconn</code> plugin)</li>
<li><code>wasp</code> (Wasp server)</li>
<li><code>wasp-cli</code> (CLI client for the Wasp node)</li>
<li><code>wasp-cluster</code> (this tool)</li>
</ul>
<p>You can find instructions in the <a href="../../../readme.html#Prerequisites">main README file</a>.</p>
<h2 id="initialize-the-cluster-configuration"><a class="header" href="#initialize-the-cluster-configuration">Initialize the cluster configuration</a></h2>
<pre><code>wasp-cluster init my-cluster
</code></pre>
<p>This will create a directory named <code>my-cluster</code>, containing the cluster
configuration file (<code>cluster.json</code>) and one subdirectory for each node.</p>
<pre><code>my-cluster/
├── cluster.json
├── goshimmer
│   ├── config.json
│   └── snapshot.bin
├── wasp0
│   └── config.json
├── wasp1
│   └── config.json
├── wasp2
│   └── config.json
└── wasp3
    └── config.json
</code></pre>
<p>By default the cluster contains 4 Wasp nodes. You can change this with the
<code>-n</code> parameter. E.g.: <code>wasp-cluster init my-cluster -n 2</code>.</p>
<p>If you need to change the default configuration of the nodes, you can do so
now, by editing the <code>config.json</code> files.</p>
<p>Note: by default <code>wasp-cluster</code> configures all nodes to store the database in
main memory: all data will be lost when the cluster is stopped (remember that
this tool is used primarily for testing). If you need a persistent database,
change the <code>inMemory</code> setting in all <code>config.json</code> files.</p>
<h2 id="start-the-cluster"><a class="header" href="#start-the-cluster">Start the cluster</a></h2>
<pre><code>cd my-cluster
wasp-cluster start
</code></pre>
<p>(Alternatively: <code>wasp-cluster start my-cluster</code>.)</p>
<p>When done using the cluster, press <code>Ctrl-C</code> to stop it.</p>
<h2 id="connecting-to-an-existing-goshimmer-network"><a class="header" href="#connecting-to-an-existing-goshimmer-network">Connecting to an existing Goshimmer network</a></h2>
<p>By default, the cluster includes a single Goshimmer node configured in such a
way that the ledger can be operated without the need for consensus. This is
good for quick tests, but is far from how Goshimmer works in a production
environment.</p>
<p>To connect the Wasp cluster to a more realistic environment (e.g. to be able to
persist the ledger), you can use the <code>docker-network</code> tool available
in the Goshimmer repository (<code>master+wasp</code> branch) in order to start a cluster of
Goshimmer nodes.</p>
<p>Example steps:</p>
<ol>
<li>Start a Goshimmer network of 2 nodes:</li>
</ol>
<pre><code>cd &lt;goshimmer&gt;/tools/docker-network
./run.sh 2 0
</code></pre>
<ol start="2">
<li>In another console, initialize a cluster of 4 Wasp nodes (<code>-n 4</code>) with no Goshimmer node (<code>-g</code>).</li>
</ol>
<pre><code>wasp-cluster init my-cluster -n 4 -g
</code></pre>
<ol start="3">
<li>Start the Wasp cluster:</li>
</ol>
<pre><code>$ cd my-cluster
$ wasp-cluster start
</code></pre>
<h2 id="running-a-disposable-cluster"><a class="header" href="#running-a-disposable-cluster">Running a disposable cluster</a></h2>
<p>If you just need to do a quick test, you can run a disposable cluster of nodes
with the default configuration with the command:</p>
<pre><code>wasp-cluster start -d
</code></pre>
<p>No need to call <code>init</code> first; this command will automatically initialize the
cluster configuration in a temporary directory, which will be removed when the
cluster is stopped.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
