(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[1507],{1871:function(e,t,n){"use strict";var r=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,a=e.className;return r.createElement("div",{role:"tabpanel",hidden:n,className:a},t)}},1137:function(e,t,n){"use strict";n.d(t,{Z:function(){return m}});var r=n(7294),a=n(4179);var o=function(){var e=(0,r.useContext)(a.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=n(6010),i="tabItem_1uMI",c="tabItemActive_2DSg";var l=37,u=39;var m=function(e){var t=e.lazy,n=e.block,a=e.defaultValue,m=e.values,d=e.groupId,f=e.className,p=o(),h=p.tabGroupChoices,v=p.setTabGroupChoices,w=(0,r.useState)(a),b=w[0],y=w[1],g=r.Children.toArray(e.children),k=[];if(null!=d){var x=h[d];null!=x&&x!==b&&m.some((function(e){return e.value===x}))&&y(x)}var O=function(e){var t=e.currentTarget,n=k.indexOf(t),r=m[n].value;y(r),null!=d&&(v(d,r),setTimeout((function(){var e,n,r,a,o,s,i,l;(e=t.getBoundingClientRect(),n=e.top,r=e.left,a=e.bottom,o=e.right,s=window,i=s.innerHeight,l=s.innerWidth,n>=0&&o<=l&&a<=i&&r>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(c),setTimeout((function(){return t.classList.remove(c)}),2e3))}),150))},C=function(e){var t,n;switch(e.keyCode){case u:var r=k.indexOf(e.target)+1;n=k[r]||k[0];break;case l:var a=k.indexOf(e.target)-1;n=k[a]||k[k.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},f)},m.map((function(e){var t=e.value,n=e.label;return r.createElement("li",{role:"tab",tabIndex:b===t?0:-1,"aria-selected":b===t,className:(0,s.Z)("tabs__item",i,{"tabs__item--active":b===t}),key:t,ref:function(e){return k.push(e)},onKeyDown:C,onFocus:O,onClick:O},n)}))),t?(0,r.cloneElement)(g.filter((function(e){return e.props.value===b}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},g.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==b})}))))}},4179:function(e,t,n){"use strict";var r=(0,n(7294).createContext)(void 0);t.Z=r},3446:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return u},metadata:function(){return m},toc:function(){return d},default:function(){return p}});var r=n(2122),a=n(9756),o=(n(7294),n(3905)),s=n(1137),i=n(1871),c=["components"],l={},u="View-Only Functions",m={unversionedId:"guide/schema/views",id:"guide/schema/views",isDocsHomePage:!1,title:"View-Only Functions",description:"View-only functions, or Views for short, are smart contract functions that only allow you",source:"@site/docs/guide/schema/views.mdx",sourceDirName:"guide/schema",slug:"/guide/schema/views",permalink:"/docs/guide/schema/views",editUrl:"https://github.com/iotaledger/chronicle.rs/tree/main/docs/docs/guide/schema/views.mdx",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Thunk Functions",permalink:"/docs/guide/schema/thunks"},next:{title:"Smart Contract Initialization",permalink:"/docs/guide/schema/init"}},d=[],f={toc:d};function p(e){var t=e.components,n=(0,a.Z)(e,c);return(0,o.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"view-only-functions"},"View-Only Functions"),(0,o.kt)("p",null,"View-only functions, or Views for short, are smart contract functions that only allow you\nto ",(0,o.kt)("em",{parentName:"p"},"retrieve")," state information about the smart contract. They have a special, limited\nISCP function context that does not allow access to functionality that could result in\nchanges to the smart contract state. That means that all access to the state storage will\nbe through immutable proxies. It also means that they cannot receive or transfer tokens,\nbecause changes to the smart contract account are by definition state changes as well."),(0,o.kt)("p",null,"Views are allowed to call other views on the same chain, but they cannot call any non-view\nsmart contract function, nor can they post cross-chain requests."),(0,o.kt)("p",null,"View functions will always return some data to their caller. It would be silly not to\nreturn data from a View because by definition it cannot have any other side effects that\nshow up elsewhere."),(0,o.kt)("p",null,"For demonstration purposes we provided a View function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"dividend")," smart contract,\ncalled 'getFactor':"),(0,o.kt)(s.Z,{defaultValue:"go",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"go",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// 'getFactor' is a simple View function. It will retrieve the factor\n// associated with the (mandatory) address parameter it was provided with.\nfunc viewGetFactor(ctx wasmlib.ScViewContext, f *GetFactorContext) {\n    // Since we are sure that the 'address' parameter actually exists we can\n    // retrieve its actual value into an ScAddress value type.\n    var address wasmlib.ScAddress = f.Params.Address().Value()\n\n    // Create an ScImmutableMap proxy to the 'members' map in the state storage.\n    // Note that for views this is an *immutable* map as opposed to the *mutable*\n    // map we can access from the *mutable* state that gets passed to funcs.\n    var members MapAddressToImmutableInt64 = f.State.Members()\n\n    // Retrieve the factor associated with the address parameter.\n    var factor int64 = members.GetInt64(address).Value()\n\n    // Set the factor in the results map of the function context.\n    // The contents of this results map is returned to the caller of the function.\n    f.Results.Factor().SetValue(factor)\n}\n"))),(0,o.kt)(i.Z,{value:"rust",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// 'getFactor' is a simple View function. It will retrieve the factor\n// associated with the (mandatory) address parameter it was provided with.\npub fn view_get_factor(_ctx: &ScViewContext, f: &GetFactorContext) {\n    // Since we are sure that the 'address' parameter actually exists we can\n    // retrieve its actual value into an ScAddress value type.\n    let address: ScAddress = f.params.address().value();\n\n    // Create an immutable map proxy to the 'members' map in the state storage.\n    // Note that for views this is an *immutable* map as opposed to the *mutable*\n    // map we can access from the *mutable* state that gets passed to funcs.\n    let members: MapAddressToImmutableInt64 = f.state.members();\n\n    // Retrieve the factor associated with the address parameter.\n    let factor: i64 = members.get_int64(&address).value();\n\n    // Set the factor in the results map of the function context.\n    // The contents of this results map is returned to the caller of the function.\n    f.results.factor().set_value(factor);\n}\n")))),(0,o.kt)("p",null,"Return values are passed to the caller through the predefined ",(0,o.kt)("inlineCode",{parentName:"p"},"results")," map associated\nwith the ISCP function context. Again, this works the same way as for Funcs, although\nFuncs do not necessarily return values to the caller. The schema tool will set up a\nfunction-specific ",(0,o.kt)("inlineCode",{parentName:"p"},"results")," structure with proxies to the result fields in this map."),(0,o.kt)("p",null,"In the next section we will look at smart contract initialization."))}p.isMDXComponent=!0},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),f=a,p=d["".concat(c,".").concat(f)]||d[f]||m[f]||o;return n?r.createElement(p,s(s({ref:t},u),{},{components:n})):r.createElement(p,s({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6010:function(e,t,n){"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}function a(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}n.d(t,{Z:function(){return a}})}}]);